/** 
 * @author Dorukhan Arslan, Didem Demirag
*/

package dtwlastversion;

import java.math.BigInteger;
import java.util.Random;

public class Scheme {
    
    protected static long timePaillierEnc = 0;
    protected static long timePaillierDec = 0;
    protected static long startEnc, finishEnc, startDec, finishDec;
    
    private boolean canEncrypt; // Whether encryption can take place.
    private boolean canDecrypt; // Whether decryption can take place.
    private BigInteger x;       // Private Key a random integer â‚¬ [1,n^2/2] 
    private BigInteger g;       // Encryption base.
    private BigInteger h;       // Encryption base.
    private BigInteger n;       // Public key.
    private BigInteger nsqr;    // The value n^2 (n squared).
    private Random prng;        // Random number generator.
    private static BigInteger cipherA;
    private static BigInteger hPowR;
    private static int countEnc = 0;
    
    public Scheme(BigInteger N, BigInteger G, BigInteger H, BigInteger X){
        canEncrypt = true;
        canDecrypt = true;
        n = N;
        g = G;
        h = H;
        x = X;
        nsqr = n.multiply(n);
        prng = new Random( System.currentTimeMillis() );
    }
    
    
    public Scheme(BigInteger N, BigInteger G, BigInteger H){
        canEncrypt = true;
        canDecrypt = false;
        n = N;
        g = G;
        h = H;
        nsqr = n.multiply(n);
        prng = new Random( System.currentTimeMillis() );
    }
    
    
    //Encrypts the given plaintext to produce ciphertext
    public BigInteger[] encrypt( BigInteger plain, BigInteger gPOWr, BigInteger hPOWr ) throws CryptoException{
        startEnc = System.nanoTime();
        
        BigInteger[] cipher = new BigInteger[2];
        BigInteger cipherA; // The ciphertext A.
        BigInteger cipherB; // The ciphertext B.
	
        cipherA = gPOWr;
        cipherB = hPOWr.multiply(((plain.multiply(n).mod(nsqr)).add(BigInteger.ONE)).mod(nsqr)).mod(nsqr);
        
        cipher[0] = cipherA;
        cipher[1] = cipherB; 
        
        finishEnc = System.nanoTime();
        timePaillierEnc += finishEnc - startEnc;
        
	return cipher;
    }
    
    
    // Online
    public BigInteger[] encrypt( BigInteger plain ) throws CryptoException{
        startEnc = System.nanoTime();
        
        BigInteger[] cipher = new BigInteger[2];
        BigInteger cipherA; // The ciphertext A.
        BigInteger cipherB; // The ciphertext B.
		long rand;         // Value generated by PRNG.
		BigInteger r;      // Random value used to hide plaintext.

	if( !canEncrypt ) {
	    throw new CryptoException( "Cannot encrypt value " +
	        plain + " because no public key was defined." );
	}
        
        do{
            r = new BigInteger(1024, new Random());
            r = r.mod(n.divide(BigInteger.valueOf(4)));
            r = r.add(BigInteger.ONE);

            cipherA = g.modPow( r, nsqr );
            
        }while((gcd(cipherA.longValue(), nsqr.longValue()) != 1)||(r.equals(BigInteger.ZERO)));
        
        cipherB = (h.modPow(r, nsqr)).multiply(((plain.multiply(n).mod(nsqr)).add(BigInteger.ONE)).mod(nsqr)).mod(nsqr);
        
        cipher[0] = cipherA;
        cipher[1] = cipherB; 

        finishEnc = System.nanoTime();
        timePaillierEnc += finishEnc - startEnc;
        
	return cipher;
    }
    
    
    // Offline
   /* public BigInteger[] encrypt( BigInteger plain ) throws CryptoException{
        
        BigInteger[] cipher = new BigInteger[2];
        // BigInteger cipherA; // The ciphertext A.
        BigInteger cipherB; // The ciphertext B.
		long rand;         // Value generated by PRNG.
		BigInteger r;      // Random value used to hide plaintext.

	if( !canEncrypt ) {
	    throw new CryptoException( "Cannot encrypt value " +
	        plain + " because no public key was defined." );
	}
        
        if (countEnc == 0) {
            do{
                r = new BigInteger(1024, new Random());
                r = r.mod(n.divide(BigInteger.valueOf(4)));
                r = r.add(BigInteger.ONE);

                cipherA = g.modPow( r, nsqr );
                
            }while((gcd(cipherA.longValue(), nsqr.longValue()) != 1)||(r.equals(BigInteger.ZERO)));
            hPowR = h.modPow(r, nsqr);
        }
        
        countEnc++;
        
        cipherB = (hPowR).multiply(((plain.multiply(n).mod(nsqr)).add(BigInteger.ONE)).mod(nsqr)).mod(nsqr);
        
        cipher[0] = cipherA;
        cipher[1] = cipherB; 

	return cipher;
    }*/

    // Decrypts the given ciphertext, which was previously encrypted using the public key.
    // It throws an exception if no decryption keys were defined
    public BigInteger decrypt( BigInteger[] cipher ) throws CryptoException {

        startDec = System.nanoTime();
        
	BigInteger plain; // The plaintext.
        BigInteger cipherA = cipher[0];
        BigInteger cipherB = cipher[1];
	BigInteger Ainv;   // Intermediate result during decryption.

	if( !canDecrypt ) {
	    throw new CryptoException( "Cannot decrypt value " +
	        cipherB.longValue() + " because no private key was defined." );
	}
        
	Ainv = (cipherA.modPow(x,nsqr)).modInverse(nsqr);
        
        plain = (((cipherB.multiply(Ainv).mod(nsqr)).subtract(BigInteger.ONE)).mod(nsqr)).divide(n);
        
        finishDec = System.nanoTime();
        timePaillierDec += finishDec - startDec;
        
	return plain;
    }
    
    public BigInteger decrypt2( BigInteger[] cipher, BigInteger x ) throws CryptoException {

        startDec = System.nanoTime();
        
	BigInteger plain; // The plaintext.
        BigInteger cipherA = cipher[0];
        BigInteger cipherB = cipher[1];
	BigInteger Ainv;   // Intermediate result during decryption.

	if( !canDecrypt ) {
	    throw new CryptoException( "Cannot decrypt value " +
	        cipherB.longValue() + " because no private key was defined." );
	}
        
	Ainv = (cipherA.modPow(x, nsqr)).modInverse(nsqr);
        
        plain = (((cipherB.multiply(Ainv).mod(nsqr)).subtract(BigInteger.ONE)).mod(nsqr)).divide(n);
        
        finishDec = System.nanoTime();
        timePaillierDec += finishDec - startDec;
        
	return plain;
    }
 
     // Partially decrypts the given ciphertext, which was previously encrypted using
     // the public key. It throws an exception if no decryption keys were defined. 
     // The private key used must be part of the original private key      
    public BigInteger[] proxyDecription( BigInteger[] cipher, BigInteger x1 ) throws CryptoException{
        
        startDec = System.nanoTime();
        
        BigInteger cipherA = cipher[0];
        BigInteger cipherB = cipher[1];
        BigInteger[] new_cipher = new BigInteger[2];
        BigInteger new_cipherB;
        BigInteger Ainv;
        
        if( !canDecrypt ) {
	    throw new CryptoException( "Cannot decrypt value " +
	        cipherB.longValue() + " because no private key was defined." );
	}
        
        new_cipherB = (cipherB.multiply((cipherA.modPow(x1, nsqr)).modInverse(nsqr))).mod(nsqr);
        
        new_cipher[0] = cipherA;
        new_cipher[1] = new_cipherB;
       
        finishDec = System.nanoTime();
        timePaillierDec += finishDec - startDec;
        
        return new_cipher;
    }
    
    
   
     // Computes the least common multiple of two numbers.
    private long lcm( long first, long second ) {

	return  first * ( second / gcd( first, second ) );

    }

    // Computes the least common multiple of two numbers.
    
    private BigInteger lcm( BigInteger first, BigInteger second ) {

	return  first.multiply( second.divide( first.gcd( second ) ) );

    }

    // Computes the greatest common denominator of two numbers.
    private long gcd( long first, long second ) {

	return  first % second == 0 ? second : gcd( second, first % second );

    }
}
